<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Neighborhood Semantics</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <script src="../js/bootstrap.min.js"></script>
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
            </div>
            <div id="navigation">
                <p></p>
            </div>
        </div>

        <div id="content">
            <h1>Neighborhood Semantics</h1>

            <div class="info">

    

    
    
</div>

<p>[<a href="../notes"><em>Notes</em></a>]</p>
<h1 id="intro">Intro</h1>
<p>We start with a typical Kripke frame <span class="math inline">\(\mathcal{F} = (\mathcal{W}, R)\)</span> where <span class="math inline">\(W\)</span> is the set of possible worlds (think possible truth assignments to your set of propositional variables) and <span class="math inline">\(R\)</span> is a binary relation on those worlds.</p>
<p>A Kripke model is just some triple <span class="math inline">\((\mathcal{W}, R, \Vdash)\)</span> where <span class="math inline">\(\Vdash\)</span> is the forcing relation which determines the relationship between various worlds <span class="math inline">\(w\in\mathcal{W}\)</span> and modal formulas. It’s characterized by the following rules:</p>
<ul>
<li><span class="math inline">\(w \Vdash \neg A\)</span> if and only if <span class="math inline">\(w \not\Vdash A\)</span></li>
<li><span class="math inline">\(w \Vdash A \to B\)</span> if and only if <span class="math inline">\(w \Vdash \neg A\)</span> or <span class="math inline">\(w \vdash B\)</span></li>
<li><span class="math inline">\(w \Vdash \Box A\)</span> if and only if for all <span class="math inline">\(u\)</span> satisfying <span class="math inline">\(wRu\)</span> we have that <span class="math inline">\(u \Vdash A.\)</span></li>
</ul>
<p>(this also subsequently implies that <span class="math inline">\(A\)</span> is possible in world <span class="math inline">\(w\)</span> if and only if it is true in at least one world <span class="math inline">\(u\)</span> adjacent to <span class="math inline">\(w,\)</span> because it’s the dual of necessity)</p>
<p>Different modal logics are generated by changing the assumptions on <span class="math inline">\(R\)</span>. For instance, forcing <span class="math inline">\(R\)</span> to be reflexive guarantees that <span class="math inline">\(\textbf{T}: \Box A \to A\)</span> will be satisfied. However, all Kripke models satisfy axiom <span class="math inline">\(\textbf{K}: \Box (A \to B) \to (\Box A \to \Box B),\)</span> which makes Kripke models very good for representing normal modal logics and very bad at representing non-normal modal logics.</p>
<p>Necessitation as an operator has become popular in representing agents’ “beliefs”. E.g., you can take an agent, represent their policy in some modal logic, and <span class="math inline">\(\Box \phi\)</span> determines their belief in <span class="math inline">\(\phi\)</span> while <span class="math inline">\(\vdash \phi\)</span> determines whether or not <span class="math inline">\(\phi\)</span> is true in that world. And this is nice for a lot of things, and Kripke models are great for modeling provability logic, for instance.</p>
<p>But if we want necessity to be some sort of probabilistic operator—<span class="math inline">\(\mathbb{P}(\phi) &gt; p\)</span>, for instance—then this becomes unsatisfactory. Probabilities don’t distribute over conditionals like that. So we want to relax this somehow.</p>
<p>Enter neighborhood semantics. We define a neighborhood frame to be a pair <span class="math inline">\((\mathcal{W}, \mathcal{N}),\)</span> where again <span class="math inline">\(\mathcal{W}\)</span> is the set of possible worlds and <span class="math inline">\(\mathcal{N}: \mathcal{W} \to 2 ^ {2 ^ \mathcal{W}}\)</span> is a “neighborhood function” which maps each world <span class="math inline">\(w \in \mathcal{W}\)</span> to a set of their neighborhoods.</p>
<p>Necessity here is defined differently: <span class="math inline">\(w \Vdash \Box \phi\)</span> if and only if the truth set of <span class="math inline">\(\phi\)</span> is a neighborhood of <span class="math inline">\(w.\)</span> That is, there has to be a neighborhood of <span class="math inline">\(w\)</span> that contains exactly all worlds in which <span class="math inline">\(\phi\)</span> is true, and then <span class="math inline">\(w \Vdash \Box \phi.\)</span></p>
<p>It’s easy to see that this is a generalization of a Kripke frame. You can convert every Kripke frame into a neighborhood frame by making the neighborhoods of each world exactly the truth sets of all <span class="math inline">\(\phi\)</span> that are necessitated by that world.</p>
<p>However, you can’t go in reverse, because having different neighborhoods attached to the same world means that criterions for necessity can be different for each <span class="math inline">\(\phi.\)</span> For instance, <span class="math inline">\(\Box \phi\)</span> might be satisfied by a neighborhood <span class="math inline">\(U\)</span> which is disjoint from a neighborhood <span class="math inline">\(V\)</span> which satisfied <span class="math inline">\(\Box \psi.\)</span> This is not representable in Kripke models—there’s only one neighborhood for each world.</p>
<p>You can pretty easily construct a world with neighborhood semantics that doesn’t satisfy <span class="math inline">\(\mathbf{K}.\)</span> Or mainly, the neighborhood associated with <span class="math inline">\(\Box(A \to B)\)</span> doesn’t have to be the same one associated with <span class="math inline">\(\Box A,\)</span> and then as a result this correspondence no longer holds in generality.</p>
<h1 id="applications-to-mathematical-reality">Applications to Mathematical Reality</h1>
<p>Ok, so why were Kripke semantics useful in the first place? They provided a very clean structure by which they could model logics in a way that allowed one to verify properties like completeness/consistency/decidability well (all Kripke models are just graphs, in essence). Partially this is because they have some formal grounding in set theory. But also because formalizing logical structures as directed graphs is just <em>really powerful</em> and a <em>really useful abstraction</em> to reason about various systems.</p>
<p>In the same vein, reducing other systems to neighborhood semantics allows you to reason about their relevant properties simply and somewhat easily. Intuitively, we have a lot of structures that deal with collections of sets <em>cough topologies cough</em> and it’d be nice to bring some of them to the study of modal logic.</p>
<p>Then there’s the question of what modal logics can simulate. Games feature prominently. Provability logic is quite famous. But more generally, modal logics are ways of <em>modeling systems and structures</em> that allow you to abstract away a bunch of irrelevant features.</p>
<p>(They’re also all fragments of FOL (first-order-logic), and as a result don’t necessarily have the same trials and tribulations that come with additional complexity)</p>

        </div>
        <div id="footer">
            <p></p>
        </div>
    </body>
</html>
